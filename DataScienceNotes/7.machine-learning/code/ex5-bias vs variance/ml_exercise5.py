# -*- coding: utf-8 -*-
"""ML-Exercise5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qi7IXsve88HB3zGeIvwAVtPCu9lVBo6O

# 机器学习练习 5 - 偏差和方差

本章代码涵盖了基于Python的解决方案，用于Coursera机器学习课程的第五个编程练习。 请参考[练习文本](ex5.pdf)了解详细的说明和公式。

代码修改并注释：黄海广，haiguang2000@qq.com
"""

import numpy as np
import scipy.io as sio
import scipy.optimize as opt
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

def load_data():
    """for ex5
    d['X'] shape = (12, 1)
    pandas has trouble taking this 2d ndarray to construct a dataframe, so I ravel
    the results
    """
    d = sio.loadmat('ex5data1.mat')
    return map(np.ravel, [d['X'], d['y'], d['Xval'], d['yval'], d['Xtest'], d['ytest']])

X, y, Xval, yval, Xtest, ytest = load_data()

df = pd.DataFrame({'water_level':X, 'flow':y})      # 水平面   流

sns.lmplot('water_level', 'flow', data=df, fit_reg=False, height=7)
plt.show()

# 下面这个语句的功能是给原本的变量增加一列 1 如 X = [10 20 30] 经过该函数后变为  [1 10; 1 20; 1 30]
X, Xval, Xtest = [np.insert(x.reshape(x.shape[0], 1), 0, np.ones(x.shape[0]), axis=1) for x in (X, Xval, Xtest)]

"""# 代价函数
<!-- <img style="float: left;" src="../img/linear_cost.png"> -->
![linear_cost.png](data:image/png;base64,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)
"""

def cost(theta, X, y):
    """
    X: R(m*n), m records, n features
    y: R(m)
    theta : R(n), linear regression parameters
    """
    m = X.shape[0]

    inner = X @ theta - y  # R(m*1)

    # 1*m @ m*1 = 1*1 in matrix multiplication
    # but you know numpy didn't do transpose in 1d array, so here is just a
    # vector inner product to itselves
    square_sum = inner.T @ inner
    cost = square_sum / (2 * m)

    return cost

theta = np.ones(X.shape[1])     # size: 1*2
cost(theta, X, y)

"""# 梯度
<!-- <img style="float: left;" src="../img/linear_gradient.png">-->
![linear_gradient.png](data:image/png;base64,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)
"""

def gradient(theta, X, y):
    m = X.shape[0]

    inner = X.T @ (X @ theta - y)  # (m,n).T @ (m, 1) -> (n, 1)

    return inner / m

gradient(theta, X, y)

"""# 正则化梯度
<!-- <img style="float: left;" src="../img/linear_reg_gradient.png"> -->
![linear_reg_cost.png](data:image/png;base64,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)
"""

def regularized_gradient(theta, X, y, l=1):
    m = X.shape[0]

    regularized_term = theta.copy()  # same shape as theta
    regularized_term[0] = 0  # don't regularize intercept theta

    regularized_term = (l / m) * regularized_term

    return gradient(theta, X, y) + regularized_term

regularized_gradient(theta, X, y)

"""# 拟合数据
> 正则化项 $\lambda=0$
"""

# 线性回归
def linear_regression_np(X, y, l=1):
    """linear regression
    args:
        X: feature matrix, (m, n+1) # with incercept x0=1
        y: target vector, (m, )
        l: lambda constant for regularization

    return: trained parameters
    """
    # init theta
    theta = np.ones(X.shape[1])     # theta = [1 1]

    # train it
    res = opt.minimize(fun=regularized_cost,
                       x0=theta,
                       args=(X, y, l),
                       method='TNC',
                       jac=regularized_gradient,
                       options={'disp': True})
    return res

def regularized_cost(theta, X, y, l=1):
    m = X.shape[0]

    regularized_term = (l / (2 * m)) * np.power(theta[1:], 2).sum()

    return cost(theta, X, y) + regularized_term

theta = np.ones(X.shape[0])

final_theta = linear_regression_np(X, y, l=0).get('x')

b = final_theta[0] # intercept  截距
m = final_theta[1] # slope      斜率

plt.scatter(X[:,1], y, label="Training data")
plt.plot(X[:, 1], X[:, 1]*m + b, label="Prediction")    # y_predict = X[:,1]*斜率  + 截距
plt.legend(loc=2)
plt.show()

training_cost, cv_cost = [], []

"""1.使用训练集的子集来拟合应模型

2.在计算训练代价和交叉验证代价时，没有用正则化

3.记住使用相同的训练集子集来计算训练代价
"""

m = X.shape[0]
for i in range(1, m+1):
#     print('i={}'.format(i))
    res = linear_regression_np(X[:i, :], y[:i], l=0)
    
    tc = regularized_cost(res.x, X[:i, :], y[:i], l=0)
    cv = regularized_cost(res.x, Xval, yval, l=0)
#     print('tc={}, cv={}'.format(tc, cv))
    
    training_cost.append(tc)
    cv_cost.append(cv)

plt.plot(np.arange(1, m+1), training_cost, label='training cost')
plt.plot(np.arange(1, m+1), cv_cost, label='cv cost')
plt.legend(loc=1)
plt.show()

"""这个模型拟合不太好, **欠拟合了**

# 创建多项式特征
"""

def prepare_poly_data(*args, power):
    """
    args: keep feeding in X, Xval, or Xtest
        will return in the same order
    """
    def prepare(x):
        # expand feature
        df = poly_features(x, power=power)
        # normalization
        ndarr = normalize_feature(df).to_numpy()
        # add intercept term
        # np.insert(ndarr, 0, np.ones(ndarr.shape[0]), axis = 1)
        # print(type(ndarr))
        # print(ndarr)
        # ndarr.insert(0, 'f',np.ones(ndarr.shape[0]))
        return np.insert(ndarr, 0, np.ones(ndarr.shape[0]),axis=1)

    return [prepare(x) for x in args]

def poly_features(x, power, as_ndarray=False):
    data = {'f{}'.format(i): np.power(x, i) for i in range(1, power + 1)}
    df = pd.DataFrame(data)

    return df.as_matrix() if as_ndarray else df

X, y, Xval, yval, Xtest, ytest = load_data()

poly_features(X, power=3)

"""# 准备多项式回归数据
1. 扩展特征到 8阶,或者你需要的阶数
2. 使用 **归一化** 来合并 $x^n$ 
3. don't forget intercept term
"""

def normalize_feature(df):
    """Applies function along input axis(default 0) of DataFrame."""
    return df.apply(lambda column: (column - column.mean()) / column.std())

X_poly, Xval_poly, Xtest_poly= prepare_poly_data(X, Xval, Xtest, power=8)
print(type(X_poly))
X_poly[:3, :]
# X_poly.head()

"""# 画出学习曲线
> 首先，我们没有使用正则化，所以 $\lambda=0$
"""

def plot_learning_curve(X, y, Xval, yval, l=0):
    training_cost, cv_cost = [], []
    m = X.shape[0]

    for i in range(1, m + 1):
        # regularization applies here for fitting parameters
        res = linear_regression_np(X[:i, :], y[:i], l=l)

        # remember, when you compute the cost here, you are computing
        # non-regularized cost. Regularization is used to fit parameters only
        tc = cost(res.x, X[:i, :], y[:i])
        cv = cost(res.x, Xval, yval)

        training_cost.append(tc)
        cv_cost.append(cv)

    plt.plot(np.arange(1, m + 1), training_cost, label='training cost')
    plt.plot(np.arange(1, m + 1), cv_cost, label='cv cost')
    plt.legend(loc=1)

plot_learning_curve(X_poly, y, Xval_poly, yval, l=0)
plt.show()

"""你可以看到训练的代价太低了，不真实. 这是 **过拟合**了

# try $\lambda=1$
"""

plot_learning_curve(X_poly, y, Xval_poly, yval, l=1)
plt.show()

"""训练代价增加了些，不再是0了。
也就是说我们减轻**过拟合**

# try $\lambda=100$
"""

plot_learning_curve(X_poly, y, Xval_poly, yval, l=100)
plt.show()

"""太多正则化了.  
变成 **欠拟合**状态

# 找到最佳的 $\lambda$
"""

l_candidate = [0, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, 3, 10]
training_cost, cv_cost = [], []

for l in l_candidate:
    res = linear_regression_np(X_poly, y, l)
    
    tc = cost(res.x, X_poly, y)
    cv = cost(res.x, Xval_poly, yval)
    
    training_cost.append(tc)
    cv_cost.append(cv)

plt.plot(l_candidate, training_cost, label='training')
plt.plot(l_candidate, cv_cost, label='cross validation')
plt.legend(loc=2)

plt.xlabel('lambda')

plt.ylabel('cost')
plt.show()

# best cv I got from all those candidates
print(l_candidate[np.argmin(cv_cost)])

# use test data to compute the cost
for l in l_candidate:
    theta = linear_regression_np(X_poly, y, l).x
    print('test cost(l={}) = {}'.format(l, cost(theta, Xtest_poly, ytest)))

"""调参后， $\lambda = 0.3$ 是最优选择，这个时候测试代价最小"""

